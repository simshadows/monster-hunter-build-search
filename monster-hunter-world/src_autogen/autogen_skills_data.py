#!/usr/bin/env python3
# -*- coding: ascii -*-

"""
Filename: autogen_skills_data.py
Author:   <contact@simshadows.com>

Reads the skills data file, and generates the source files.
"""

from common import json_read, file_write, is_upper_snake_case, is_safe_name

SKILLS_JSON_PATH  = "./data/database_skills.json"
SKILLS_H_PATH = "./src/database/database_skills.h"
SKILLS_CPP_PATH = "./src/database/autogenerated/database_skills.cpp"

#########################################################################################

SKILLS_H_BASE = """
/*
 * This file is auto-generated.
 * Do not edit directly!
 */

#ifndef SKILLS_DATABASE_H
#define SKILLS_DATABASE_H

#include <string>
#include <vector>

#include "../core/core.h"

namespace SkillsDatabase
{{

using MHWIBuildSearch::Skill;
using MHWIBuildSearch::SetBonus;

{skill_declarations}

{skill_nids}

{setbonus_declarations}

extern const std::array<const SetBonus*, {num_setbonuses}> g_all_setbonuses;

const Skill* get_skill(const std::string& skill_id) noexcept;

const SetBonus* get_setbonus(const std::string& setbonus_id) noexcept;

}} // namespace

#endif // SKILLS_DATABASE_H
"""

#########################################################################################

SKILLS_CPP_BASE = """
/*
 * This file is auto-generated.
 * Do not edit directly!
 */

#include <unordered_map>

#include "../database_skills.h"

namespace SkillsDatabase
{{


{skill_definitions}


{setbonus_definitions}


static const std::unordered_map<std::string, const Skill*> g_skills_map = {{
{skill_map_elements}
}};


static const std::unordered_map<std::string, const SetBonus*> g_setbonus_map = {{
{setbonus_map_elements}
}};


const std::array<const SetBonus*, {num_setbonuses}> g_all_setbonuses = {{
{setbonus_array_elements}
}};


const Skill* get_skill(const std::string& skill_id) noexcept {{
    return g_skills_map.at(skill_id);
}}


const SetBonus* get_setbonus(const std::string& setbonus_id) noexcept {{
    return g_setbonus_map.at(setbonus_id);
}}


}} // namespace
"""

#########################################################################################

MINIMUM_SKILL_STATES = 2

def parse_skills(j):
    skills = {}
    names = set() # Used only for validation
    for (skill_id, skill_json) in j.items():
        t = {
                # Name to bind globally in the C++ source code
                "identifier":     "g_skill_" + skill_id.lower(),
                "nid_identifier": "g_skillnid_" + skill_id.lower(),

                # Struct data
                "skill_id":     skill_id,
                "skill_name":   skill_json["name"],
                "normal_limit": skill_json["limit"],
                "secret_limit": skill_json.get("secret_limit", skill_json["limit"]),
                "states":       skill_json.get("states", MINIMUM_SKILL_STATES),
            }

        # ID
        if not is_upper_snake_case(t["skill_id"]):
            raise ValueError("IDs must be upper case letters, numbers, or underscores.")

        # Names
        if not is_safe_name(t["skill_name"]):
            raise ValueError("Name may not be safe.")
        elif t["skill_name"] in names:
            raise ValueError("Names must be unique.")
        names.add(t["skill_name"])

        # Limits
        if t["normal_limit"] < 1:
            raise ValueError("Limits must be 1 or greater.")
        elif t["secret_limit"] < t["normal_limit"]:
            raise ValueError("Secret limits must not be less than their respective normal limit.")

        # States
        if t["states"] < 2:
            raise ValueError("States must be 2 or greater.")

        skills[t["skill_id"]] = t
    return skills

def parse_setbonuses(j):
    setbonuses = {}
    names = set() # Used only for validation
    for (sb_id, sb_json) in j.items():
        t = {
                # Name to bind globally in the C++ source code
                "identifier": "g_setbonus_" + sb_id.lower(),

                # Struct data
                "sb_id": sb_id,
                "sb_name": sb_json["name"],
                "stages": [(x["parts"], x["skill"]) for x in sb_json["stages"]]
            }

        # ID
        if not is_upper_snake_case(t["sb_id"]):
            raise ValueError("IDs must be upper case letters, numbers, or underscores.")

        # Names
        if not is_safe_name(t["sb_name"]):
            raise ValueError("Name may not be safe.")
        elif t["sb_name"] in names:
            raise ValueError("Names must be unique.")
        names.add(t["sb_name"])

        # Stages
        if any(((x < 1) or (x > 5)) for (x, _) in t["stages"]):
            raise ValueError("Set bonus stages must between between 1 and 5 pieces.")

        setbonuses[t["sb_id"]] = t
    return setbonuses

def generate_skills_source():
    j = json_read(SKILLS_JSON_PATH)

    skills = parse_skills(j["skills"])
    setbonuses = parse_setbonuses(j["set_bonuses"])

    skill_declarations = []
    skill_nids         = []
    skill_definitions  = []
    skill_map_elements = []

    setbonus_declarations   = []
    setbonus_definitions    = []
    setbonus_map_elements   = []
    setbonus_array_elements = []
    num_setbonuses          = len(setbonuses)

    next_nid = 0
    for (_, skill) in skills.items():
        skill_declarations.append(
                    f"extern const Skill {skill['identifier']};"
                )
        skill_nids.append(
                    f"constexpr std::size_t {skill['nid_identifier']} = {next_nid};"
                )
        skill_definitions.append(
                    f"const Skill {skill['identifier']} = {{\n"
                    f"    {next_nid}, // nid\n"
                    f"    \"{skill['skill_id']}\", // id\n"
                    f"    \"{skill['skill_name']}\", // name\n"
                    f"    {skill['normal_limit']}, // normal_limit\n"
                    f"    {skill['secret_limit']}, // secret_limit\n"
                    f"    {skill['states']} // states\n"
                    f"}};"
                )
        skill_map_elements.append(
                    f"    {{ \"{skill['skill_id']}\", &{skill['identifier']} }},"
                )
        next_nid += 1

    for (_, setbonus) in setbonuses.items():
        stages = []
        highest_stage = 0
        for (parts, skill_id) in setbonus["stages"]:
            stages.append(f"        {{ {parts}, &{skills[skill_id]['identifier']} }},")
            if parts > highest_stage:
                highest_stage = parts
        stages_str = "\n".join(stages)

        setbonus_declarations.append(
                    f"extern const SetBonus {setbonus['identifier']};"
                )
        setbonus_definitions.append(
                    f"const SetBonus {setbonus['identifier']} = {{\n"
                    f"    \"{setbonus['sb_id']}\", // id\n"
                    f"    \"{setbonus['sb_name']}\", // name\n"
                    f"    {{ // stages\n"
                    f"{stages_str}\n"
                    f"    }},\n"
                    f"    {highest_stage} // highest_stage\n"
                    f"}};"
                )
        setbonus_map_elements.append(
                    f"    {{ \"{setbonus['sb_id']}\", &{setbonus['identifier']} }},"
                )
        setbonus_array_elements.append(
                    f"    &{setbonus['identifier']},"
                )

    h_file_data = SKILLS_H_BASE.format(
            skill_declarations="\n".join(skill_declarations),
            skill_nids="\n".join(skill_nids),
            setbonus_declarations="\n".join(setbonus_declarations),
            num_setbonuses=num_setbonuses,
        )
    file_write(SKILLS_H_PATH, data=h_file_data)

    cpp_file_data = SKILLS_CPP_BASE.format(
            skill_definitions="\n\n".join(skill_definitions),
            setbonus_definitions="\n\n".join(setbonus_definitions),
            skill_map_elements="\n".join(skill_map_elements),
            setbonus_map_elements="\n".join(setbonus_map_elements),
            setbonus_array_elements="\n".join(setbonus_array_elements),
            num_setbonuses=num_setbonuses,
        )
    file_write(SKILLS_CPP_PATH, data=cpp_file_data)


generate_skills_source()

